\ProvidesPackage{luaxml}[{{DATE}} LuaXML package]

\RequirePackage{luacode}

% ToDo: move Lua code to a standalone library, which could be used from other LuaLaTeX packages 
% ToDo: add support for use of  transformation rules for other XML syntaxes -- using LaTeX command?


\begin{luacode*}
-- provide global object with all variables we will use
luaxml_sty = {
  current = {
    transformation = "default",
  },
  packages = {},
  -- we want to support multiple transformation objects, they will be stored here
  transformations = {},
}
luaxml_sty.packages.transform = require "luaxml-transform"
luaxml_sty.packages.domobject = require "luaxml-domobject"

-- declare default transformer, used if no explicit transformer is used in LuaXML LaTeX commands
luaxml_sty.transformations.default = luaxml_sty.packages.transform.new()

-- debuggind functions
function luaxml_sty.error(...)
  local arg = {...}
  print("LuaXML error: " .. table.concat(arg, " "))
end

function luaxml_sty.debug(...)
  local arg = {...}
  print("LuaXML: " .. table.concat(arg, " "))
end

-- add luaxml-transform rule
function luaxml_sty.add_rule(current, selector, rule)
  if current == "" then
   current = luaxml_sty.current.transformation
  end
  -- the +v parameter type in LaTeX replaces newlines with \obeyedline. we need to replace it back to newlines
  rule = rule:gsub("\\obeyedline", "\n")
  luaxml_sty.debug("************* haha: " .. selector, rule, current)
  local transform = luaxml_sty.transformations[current]
  if not transform then 
    luaxml_sty.error("Cannot find LuaXML transform object: " .. (current or ""))
    return nil, "Cannot find LuaXML transform object: " .. (current or "")
  end
  transform:add_action(selector, rule)
end

-- by default, we will use XML parser, so use_xml is set to true
luaxml_sty.use_xml = true

function luaxml_sty.use_xml()
  luaxml_sty.use_xml = true
end

function luaxml_sty.use_html()
  luaxml_sty.use_xml = false
end

function luaxml_sty.parse_snippet(current, xml_string)
  local domobject = luaxml_sty.packages.domobject
  if current == "" then
    current = luaxml_sty.current.transformation
  end
  local transform = luaxml_sty.transformations[current]
  local dom
  if luaxml_sty.use_xml then
    dom = domobject.parse(xml_string)
  else
    dom = domobject.html_parse(xml_string)
  end
  transform:add_action(".ahoj", "xxx: %s")
  print(dom:serialize())
  local result = transform:process_dom(dom)
  luaxml_sty.packages.transform.print_tex(result)
end

\end{luacode*}


\ExplSyntaxOn

% select current transformer object
\NewDocumentCommand\LXMLUseTransformer{m}{
  \directlua{
luaxml_sty.current.transformation = "#1",
}}

% declare new transformer object
\NewDocumentCommand\LXMLDeclareTransformer{m}{
  \directlua{
    luaxml_sty.transformations["#1"] = luaxml_sty.packages.transform.new()
  }
}

% add transformer rule
% #1 transformer object name -- empty = default
% #2 CSS selector 
% #3 transformer rule
\NewDocumentCommand\LXMLRule{O{} m +v}{
  \directlua{
    luaxml_sty.add_rule("#1", "#2", "\luaescapestring{#3}")
    %luaxml_sty.add_rule("#1", "#2", "#3")
  }
}


% \LXMLSnippet* - parse using XML parser
% \LXMLSnippet  - parse using HTML parser
% #2 transformer name -- empty = default
% #3 XML string
\NewDocumentCommand\LXMLSnippet{s O{} m}{
  \IfBooleanTF{#1}{
    \directlua{luaxml_sty.use_html()}
  }{
    \directlua{luaxml_sty.use_xml()}
  }
  \directlua{
    luaxml_sty.parse_snippet("\luaescapestring{#2}", [[\detokenize{#3}]])
  }
}

\ExplSyntaxOff
\endinput
